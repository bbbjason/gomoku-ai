Question:
I would like you to implement a module named TopModule with the following
interface. All input and output ports are one bit unless otherwise
specified.

 - input  clk
 - input  reset
 - input  s
 - input  w
 - output z

The module should implement a finite state machine with inputs s and w.
Assume that the FSM begins in a reset state called A, as depicted below.
The FSM remains in state A as long as s = 0, and it moves to state B when
s = 1. Once in state B the FSM examines the value of the input w in the
next three clock cycles. If w = 1 in exactly two of these clock cycles,
then the FSM has to set an output z to 1 in the following clock cycle.
Otherwise z has to be 0. The FSM continues checking w for the next three
clock cycles, and so on. Use as few states as possible. Note that the s
input is used only in state A, so you need to consider just the w input.
Assume reset is active high synchronous. Assume all sequential logic is
triggered on the positive edge of the clock.

Answer:
[BEGIN]
module TopModule (
  input clk,
  input reset,
  input s,
  input w,
  output reg z
);

  parameter A=0, B=1, C=2, S10=3, S11=4, S20=5, S21=6, S22=7;
  reg [2:0] state, next;

  always @(posedge clk) begin
    if (reset) state <= A;
    else state <= next;
  end

  always_comb begin
    case (state)
      A: next = s ? B : A;
      B: next = w ? S11 : S10;
      C: next = w ? S11 : S10;
      S10: next = w ? S21 : S20;
      S11: next = w ? S22 : S21;
      S20: next = B;
      S21: next = w ? C : B;
      S22: next = w ? B : C;
      default: next = 'x;
    endcase
  end

  assign z = (state == C);

endmodule
[DONE]
